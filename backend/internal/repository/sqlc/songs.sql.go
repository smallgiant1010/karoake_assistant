// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: songs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :exec
INSERT INTO songs (Language, Title, IsGenerated, Lyrics)
VALUES ($1, $2, $3, $4)
`

type CreateSongParams struct {
	Language    string      `db:"language" json:"Language"`
	Title       string      `db:"title" json:"Title"`
	Isgenerated pgtype.Bool `db:"isgenerated" json:"Isgenerated"`
	Lyrics      pgtype.Text `db:"lyrics" json:"Lyrics"`
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) error {
	_, err := q.db.Exec(ctx, createSong,
		arg.Language,
		arg.Title,
		arg.Isgenerated,
		arg.Lyrics,
	)
	return err
}

const getSongByID = `-- name: GetSongByID :one
SELECT songid, language, title, isgenerated, lyrics FROM songs
WHERE songs.songID = $1
`

func (q *Queries) GetSongByID(ctx context.Context, songid int64) (Song, error) {
	row := q.db.QueryRow(ctx, getSongByID, songid)
	var i Song
	err := row.Scan(
		&i.Songid,
		&i.Language,
		&i.Title,
		&i.Isgenerated,
		&i.Lyrics,
	)
	return i, err
}

const getSongsByArtist = `-- name: GetSongsByArtist :many
SELECT s.Title, s.Language, s.Lyrics, s.IsGenerated, a.Name
FROM artists a 
LEFT JOIN artistsToSongs j ON a.ArtistID = j.ArtistID
RIGHT JOIN songs s ON j.SongID = s.SongID
WHERE a.Name LIKE $1
ORDER BY a.ArtistID
`

type GetSongsByArtistRow struct {
	Title       string      `db:"title" json:"Title"`
	Language    string      `db:"language" json:"Language"`
	Lyrics      pgtype.Text `db:"lyrics" json:"Lyrics"`
	Isgenerated pgtype.Bool `db:"isgenerated" json:"Isgenerated"`
	Name        string      `db:"name" json:"Name"`
}

func (q *Queries) GetSongsByArtist(ctx context.Context, name string) ([]GetSongsByArtistRow, error) {
	rows, err := q.db.Query(ctx, getSongsByArtist, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSongsByArtistRow
	for rows.Next() {
		var i GetSongsByArtistRow
		if err := rows.Scan(
			&i.Title,
			&i.Language,
			&i.Lyrics,
			&i.Isgenerated,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongsByTitle = `-- name: GetSongsByTitle :many
SELECT s.Title, s.Language, s.Lyrics, s.IsGenerated, a.Name
FROM artists a 
LEFT JOIN artistsToSongs j ON a.ArtistID = j.ArtistID
RIGHT JOIN songs s ON j.SongID = s.SongID
WHERE s.Title LIKE $1
ORDER BY s.SongID
`

type GetSongsByTitleRow struct {
	Title       string      `db:"title" json:"Title"`
	Language    string      `db:"language" json:"Language"`
	Lyrics      pgtype.Text `db:"lyrics" json:"Lyrics"`
	Isgenerated pgtype.Bool `db:"isgenerated" json:"Isgenerated"`
	Name        string      `db:"name" json:"Name"`
}

func (q *Queries) GetSongsByTitle(ctx context.Context, title string) ([]GetSongsByTitleRow, error) {
	rows, err := q.db.Query(ctx, getSongsByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSongsByTitleRow
	for rows.Next() {
		var i GetSongsByTitleRow
		if err := rows.Scan(
			&i.Title,
			&i.Language,
			&i.Lyrics,
			&i.Isgenerated,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
